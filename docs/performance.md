# Профілювання продуктивності застосунку

## 1. Методологія профілювання

### Платформа

- **Мова**: Java 21
- **Фреймворк**: Spring Boot
- **База даних**: PostgreSQL
- **IDE**: IntelliJ IDEA

### Профілювальники

- **CPU**: VisualVM
- **Пам’ять**: JProfiler / VisualVM Heap Dump
- **База даних**: Spring Boot Actuator, p6spy

---

## 2. Ключові метрики продуктивності

- **Час відповіді API (ms)** — середній час виконання HTTP-запитів.
- **CPU Time (%)** — відсоток часу, який витрачає певна функція.
- **Використання пам’яті** — обсяг зайнятого Heap / Non-Heap простору.
- **Час виконання SQL-запитів** — визначення повільних (slow) запитів.

---

## 3. Тестові сценарії

### 3.1 Авторизація
- **Метод**: `POST /api/auth/signin`
- **Опис**: Авторизація користувача з валідними обліковими даними.

### 3.2 Реєстрація
- **Метод**: `POST /api/auth/signup`
- **Опис**: Створення нового користувача (унікальні логін та email).

### 3.3 Отримання карток
- **Метод**: `GET /api/cards?deckId={id}`
- **Опис**: Завантаження карток для обраної колоди (імітація сесії перед навчанням).

---

## 4. Інструменти профілювання

- **VisualVM**: Аналіз CPU-активності та використання пам’яті.
- **JProfiler**: Поглиблений аналіз пам’яті та витоків.
- **Spring Boot Actuator**: Перегляд статистики виконання REST-запитів.
- **p6spy**: Логування SQL-запитів, тривалості, параметрів.

---

## 5. Результати профілювання

| Сценарій           | Середній час відповіді | CPU (%) | Heap пам’ять | SQL-запит                      |
|--------------------|------------------------|---------|---------------|--------------------------------|
| Авторизація        | 120 ms                 | 18%     | 88 MB         | `SELECT user...` (45 ms)       |
| Реєстрація         | 180 ms                 | 22%     | 95 MB         | `INSERT INTO user...` (55 ms)  |
| Отримання карток   | 330 ms                 | 25%     | 102 MB        | `JOIN card + note...` (187 ms) |

---

### Виявлені "гарячі точки"

#### JwtUtils.generateJwtToken()
- **Проблема**: Генерація токена займає значний час через шифрування (RSA).
- **Рекомендація**: Кешувати ключі або перейти на HMAC, якщо безпека не погіршиться.

#### UserRepository.existsByEmail() / existsByUsername()
- **Проблема**: Виконуються два окремі SQL-запити під час реєстрації.
- **Рекомендація**: Об'єднати в один запит через `OR`.

#### JOIN-запити у таблиці card
- **Проблема**: Відсутність індексів на полях `note_id` та `desk_id`.
- **Рекомендація**: Додати індекси, використовувати `@EntityGraph` або `JOIN FETCH` для оптимізації.

---

## 6. Рекомендації

- Додати індекси на `card.desk_id` та `card.note_id`.
- Об'єднати перевірки `username` і `email` у реєстрації в один запит.
- Перевірити можливість зменшення часу генерації JWT (HMAC замість RSA).
- Використовувати `@EntityGraph` або `fetch join` у JPA-запитах для оптимізації зв’язків.
- Додати `spring.datasource.hikari.maximum-pool-size` для оптимального пулу з’єднань.

---

